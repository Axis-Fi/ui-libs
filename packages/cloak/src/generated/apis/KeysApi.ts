/* tslint:disable */
/* eslint-disable */
/**
 * Cloak Key Management API
 * Cloak provides a simple key management API for BN254 key pairs. It allows users to create a key pair where the private key will only be revealed after a certain time. The time is determined by the conclusion of an auction that the key is mapped to based on observations of blockchain events.
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
  EncryptLotIdPost200Response,
  EncryptRequest,
  PublicKey,
} from "../models/index";
import {
  EncryptLotIdPost200ResponseFromJSON,
  EncryptLotIdPost200ResponseToJSON,
  EncryptRequestFromJSON,
  EncryptRequestToJSON,
  PublicKeyFromJSON,
  PublicKeyToJSON,
} from "../models/index";

export interface EncryptLotIdPostRequest {
  xChainId: number;
  xAuctionHouse: string;
  lotId: number;
  encryptRequest: EncryptRequest;
}

export interface HintsLotIdNumExternalGetRequest {
  xChainId: number;
  xAuctionHouse: string;
  lotId: number;
  num: number;
}

export interface HintsLotIdNumGetRequest {
  xChainId: number;
  xAuctionHouse: string;
  lotId: number;
  num: number;
}

export interface PrivateKeyLotIdGetRequest {
  xChainId: number;
  xAuctionHouse: string;
  lotId: number;
}

export interface PublicKeyLotIdGetRequest {
  xChainId: number;
  xAuctionHouse: string;
  lotId: number;
}

/**
 *
 */
export class KeysApi extends runtime.BaseAPI {
  /**
   * Encrypt a bid for a given lot ID. The bid will be encrypted using the public key for the lot and a randomized seed.
   */
  async encryptLotIdPostRaw(
    requestParameters: EncryptLotIdPostRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<EncryptLotIdPost200Response>> {
    if (
      requestParameters.xChainId === null ||
      requestParameters.xChainId === undefined
    ) {
      throw new runtime.RequiredError(
        "xChainId",
        "Required parameter requestParameters.xChainId was null or undefined when calling encryptLotIdPost.",
      );
    }

    if (
      requestParameters.xAuctionHouse === null ||
      requestParameters.xAuctionHouse === undefined
    ) {
      throw new runtime.RequiredError(
        "xAuctionHouse",
        "Required parameter requestParameters.xAuctionHouse was null or undefined when calling encryptLotIdPost.",
      );
    }

    if (
      requestParameters.lotId === null ||
      requestParameters.lotId === undefined
    ) {
      throw new runtime.RequiredError(
        "lotId",
        "Required parameter requestParameters.lotId was null or undefined when calling encryptLotIdPost.",
      );
    }

    if (
      requestParameters.encryptRequest === null ||
      requestParameters.encryptRequest === undefined
    ) {
      throw new runtime.RequiredError(
        "encryptRequest",
        "Required parameter requestParameters.encryptRequest was null or undefined when calling encryptLotIdPost.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (
      requestParameters.xChainId !== undefined &&
      requestParameters.xChainId !== null
    ) {
      headerParameters["x-chain-id"] = String(requestParameters.xChainId);
    }

    if (
      requestParameters.xAuctionHouse !== undefined &&
      requestParameters.xAuctionHouse !== null
    ) {
      headerParameters["x-auction-house"] = String(
        requestParameters.xAuctionHouse,
      );
    }

    const response = await this.request(
      {
        path: `/encrypt/{lot_id}`.replace(
          `{${"lot_id"}}`,
          encodeURIComponent(String(requestParameters.lotId)),
        ),
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: EncryptRequestToJSON(requestParameters.encryptRequest),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      EncryptLotIdPost200ResponseFromJSON(jsonValue),
    );
  }

  /**
   * Encrypt a bid for a given lot ID. The bid will be encrypted using the public key for the lot and a randomized seed.
   */
  async encryptLotIdPost(
    requestParameters: EncryptLotIdPostRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<EncryptLotIdPost200Response> {
    const response = await this.encryptLotIdPostRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Retrieve optimal decrypts for the next N bids to be decrypted on the a given lot ID. Works for any lot ID, assuming the private key for the auction has been submitted to the contract.
   */
  async hintsLotIdNumExternalGetRaw(
    requestParameters: HintsLotIdNumExternalGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<string>>> {
    if (
      requestParameters.xChainId === null ||
      requestParameters.xChainId === undefined
    ) {
      throw new runtime.RequiredError(
        "xChainId",
        "Required parameter requestParameters.xChainId was null or undefined when calling hintsLotIdNumExternalGet.",
      );
    }

    if (
      requestParameters.xAuctionHouse === null ||
      requestParameters.xAuctionHouse === undefined
    ) {
      throw new runtime.RequiredError(
        "xAuctionHouse",
        "Required parameter requestParameters.xAuctionHouse was null or undefined when calling hintsLotIdNumExternalGet.",
      );
    }

    if (
      requestParameters.lotId === null ||
      requestParameters.lotId === undefined
    ) {
      throw new runtime.RequiredError(
        "lotId",
        "Required parameter requestParameters.lotId was null or undefined when calling hintsLotIdNumExternalGet.",
      );
    }

    if (requestParameters.num === null || requestParameters.num === undefined) {
      throw new runtime.RequiredError(
        "num",
        "Required parameter requestParameters.num was null or undefined when calling hintsLotIdNumExternalGet.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      requestParameters.xChainId !== undefined &&
      requestParameters.xChainId !== null
    ) {
      headerParameters["x-chain-id"] = String(requestParameters.xChainId);
    }

    if (
      requestParameters.xAuctionHouse !== undefined &&
      requestParameters.xAuctionHouse !== null
    ) {
      headerParameters["x-auction-house"] = String(
        requestParameters.xAuctionHouse,
      );
    }

    const response = await this.request(
      {
        path: `/hints/{lot_id}/{num}/external`
          .replace(
            `{${"lot_id"}}`,
            encodeURIComponent(String(requestParameters.lotId)),
          )
          .replace(
            `{${"num"}}`,
            encodeURIComponent(String(requestParameters.num)),
          ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Retrieve optimal decrypts for the next N bids to be decrypted on the a given lot ID. Works for any lot ID, assuming the private key for the auction has been submitted to the contract.
   */
  async hintsLotIdNumExternalGet(
    requestParameters: HintsLotIdNumExternalGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<string>> {
    const response = await this.hintsLotIdNumExternalGetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Retrieve optimal decrypts for the next N bids to be decrypted on the a given lot ID. Assumes that the key information for the auction was created by the service.
   */
  async hintsLotIdNumGetRaw(
    requestParameters: HintsLotIdNumGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<string>>> {
    if (
      requestParameters.xChainId === null ||
      requestParameters.xChainId === undefined
    ) {
      throw new runtime.RequiredError(
        "xChainId",
        "Required parameter requestParameters.xChainId was null or undefined when calling hintsLotIdNumGet.",
      );
    }

    if (
      requestParameters.xAuctionHouse === null ||
      requestParameters.xAuctionHouse === undefined
    ) {
      throw new runtime.RequiredError(
        "xAuctionHouse",
        "Required parameter requestParameters.xAuctionHouse was null or undefined when calling hintsLotIdNumGet.",
      );
    }

    if (
      requestParameters.lotId === null ||
      requestParameters.lotId === undefined
    ) {
      throw new runtime.RequiredError(
        "lotId",
        "Required parameter requestParameters.lotId was null or undefined when calling hintsLotIdNumGet.",
      );
    }

    if (requestParameters.num === null || requestParameters.num === undefined) {
      throw new runtime.RequiredError(
        "num",
        "Required parameter requestParameters.num was null or undefined when calling hintsLotIdNumGet.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      requestParameters.xChainId !== undefined &&
      requestParameters.xChainId !== null
    ) {
      headerParameters["x-chain-id"] = String(requestParameters.xChainId);
    }

    if (
      requestParameters.xAuctionHouse !== undefined &&
      requestParameters.xAuctionHouse !== null
    ) {
      headerParameters["x-auction-house"] = String(
        requestParameters.xAuctionHouse,
      );
    }

    const response = await this.request(
      {
        path: `/hints/{lot_id}/{num}`
          .replace(
            `{${"lot_id"}}`,
            encodeURIComponent(String(requestParameters.lotId)),
          )
          .replace(
            `{${"num"}}`,
            encodeURIComponent(String(requestParameters.num)),
          ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Retrieve optimal decrypts for the next N bids to be decrypted on the a given lot ID. Assumes that the key information for the auction was created by the service.
   */
  async hintsLotIdNumGet(
    requestParameters: HintsLotIdNumGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<string>> {
    const response = await this.hintsLotIdNumGetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Create a new BN254 key pair. Returns the public key coordinates.
   */
  async newKeyPairPostRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<PublicKey>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/new_key_pair`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PublicKeyFromJSON(jsonValue),
    );
  }

  /**
   * Create a new BN254 key pair. Returns the public key coordinates.
   */
  async newKeyPairPost(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<PublicKey> {
    const response = await this.newKeyPairPostRaw(initOverrides);
    return await response.value();
  }

  /**
   * Retrieve the private key for a given lot ID. The private key will only be revealed after the auction for the lot has concluded. If an auction is cancelled, the private key will not be revealed.
   */
  async privateKeyLotIdGetRaw(
    requestParameters: PrivateKeyLotIdGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (
      requestParameters.xChainId === null ||
      requestParameters.xChainId === undefined
    ) {
      throw new runtime.RequiredError(
        "xChainId",
        "Required parameter requestParameters.xChainId was null or undefined when calling privateKeyLotIdGet.",
      );
    }

    if (
      requestParameters.xAuctionHouse === null ||
      requestParameters.xAuctionHouse === undefined
    ) {
      throw new runtime.RequiredError(
        "xAuctionHouse",
        "Required parameter requestParameters.xAuctionHouse was null or undefined when calling privateKeyLotIdGet.",
      );
    }

    if (
      requestParameters.lotId === null ||
      requestParameters.lotId === undefined
    ) {
      throw new runtime.RequiredError(
        "lotId",
        "Required parameter requestParameters.lotId was null or undefined when calling privateKeyLotIdGet.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      requestParameters.xChainId !== undefined &&
      requestParameters.xChainId !== null
    ) {
      headerParameters["x-chain-id"] = String(requestParameters.xChainId);
    }

    if (
      requestParameters.xAuctionHouse !== undefined &&
      requestParameters.xAuctionHouse !== null
    ) {
      headerParameters["x-auction-house"] = String(
        requestParameters.xAuctionHouse,
      );
    }

    const response = await this.request(
      {
        path: `/private_key/{lot_id}`.replace(
          `{${"lot_id"}}`,
          encodeURIComponent(String(requestParameters.lotId)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Retrieve the private key for a given lot ID. The private key will only be revealed after the auction for the lot has concluded. If an auction is cancelled, the private key will not be revealed.
   */
  async privateKeyLotIdGet(
    requestParameters: PrivateKeyLotIdGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<string> {
    const response = await this.privateKeyLotIdGetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Retrieve the public key for a given lot ID.
   */
  async publicKeyLotIdGetRaw(
    requestParameters: PublicKeyLotIdGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<PublicKey>> {
    if (
      requestParameters.xChainId === null ||
      requestParameters.xChainId === undefined
    ) {
      throw new runtime.RequiredError(
        "xChainId",
        "Required parameter requestParameters.xChainId was null or undefined when calling publicKeyLotIdGet.",
      );
    }

    if (
      requestParameters.xAuctionHouse === null ||
      requestParameters.xAuctionHouse === undefined
    ) {
      throw new runtime.RequiredError(
        "xAuctionHouse",
        "Required parameter requestParameters.xAuctionHouse was null or undefined when calling publicKeyLotIdGet.",
      );
    }

    if (
      requestParameters.lotId === null ||
      requestParameters.lotId === undefined
    ) {
      throw new runtime.RequiredError(
        "lotId",
        "Required parameter requestParameters.lotId was null or undefined when calling publicKeyLotIdGet.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      requestParameters.xChainId !== undefined &&
      requestParameters.xChainId !== null
    ) {
      headerParameters["x-chain-id"] = String(requestParameters.xChainId);
    }

    if (
      requestParameters.xAuctionHouse !== undefined &&
      requestParameters.xAuctionHouse !== null
    ) {
      headerParameters["x-auction-house"] = String(
        requestParameters.xAuctionHouse,
      );
    }

    const response = await this.request(
      {
        path: `/public_key/{lot_id}`.replace(
          `{${"lot_id"}}`,
          encodeURIComponent(String(requestParameters.lotId)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PublicKeyFromJSON(jsonValue),
    );
  }

  /**
   * Retrieve the public key for a given lot ID.
   */
  async publicKeyLotIdGet(
    requestParameters: PublicKeyLotIdGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<PublicKey> {
    const response = await this.publicKeyLotIdGetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }
}
